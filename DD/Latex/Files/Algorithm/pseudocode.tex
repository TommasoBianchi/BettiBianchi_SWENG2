Insert Meeting

- mark all overlapping meetings as inconsistent
- mark new meeting as inconsistent if overlapping with any other one
- if at this point new meeting is inconsistent (return)

- compute the best travel from the default location before new meeting to the location of new meeting (call it fromdef travel)
- compute the best travel from the location of new meeting to the default location after new meeting (call it todef travel)

- take the last consistent meeting with end date before the start date of new meeting (call it before meeting)
- take the first consistent meeting with start date after the end date of new meeting (call it after meeting)

- [A] if fromdef travel is compatible with before meeting or if there is no before meeting, goto [B]
- compute the best travel from the arriving location of the leaving travel of before meeting to the location of new meeting
- if the previous travel is not possible, compute the best travel directly from before meeting to new meeting
- [B] if todef travel is compatible with after meeting or if there is no after meeting, goto [C]
- compute the best travel from the leaving location of the arriving travel of after meeting to the location of new meeting
- if the previous travel is not possible, compute the best travel directly from new meeting to after meeting

- [C] if new meeting has not both an arriving and a leaving travel, mark it as inconsistent and delete its travels (return)
- check that every break overlapping with the time period between the start of the travel to new meeting and the end of the travel leaving new meeting remain doable, otherwise mark new meeting as inconsistent and delete its travels (return)
- update actual time of breaks if needed
- save new meeting and its travels (return)


Compute Best Travel

- for each travel means in the preference list, ask the external provider for a path
- compute the weighted preference list
- filter the weighted preference list using the constraints
- return the path corresponding to the first item of the weighted preference list

Mark Meeting as Inconsistent

- flip a bit on the meeting
- create a warning

\clearpage

\begin{algorithmic}[1]
\Function{insert\_meeting}{$new\_meeting$, $user$}
	\State $overlapping\_meetings$ := all meetings of $user$ such that they overlap in time with $new\_meeting$
	\ForAll{$meeting$ \textbf{in} $overlapping\_meetings$}
		\State mark $meeting$ as inconsistent
	\EndFor
	\If{$overlapping\_meetings$ is not empty}
		\State mark $new\_meeting$ as inconsistent
		\State \textbf{return}
	\EndIf
	\Statex
	\State $defloc\_before$ := the default location before the beginning of $new\_meeting$
	\State $defloc\_after$ := the default location after the end of $new\_meeting$
	\Statex
	\State $arriving\_travel$ := \Call{best\_travel}{$defloc\_before.location$, $new\_meeting.location$}
	\State $leaving\_travel$ := \Call{best\_travel}{$new\_meeting.location$, $defloc\_after.location$}
	\Statex
	\State $before\_meeting$ := the last consistent meeting such that its end date is before the start date of $new\_meeting$
	\State $after\_meeting$ := the first consistent meeting such that its start date is after the end date of $new\_meeting$
	\Statex
	\If{$before\_meeting$ is not NULL \textbf{and} $arriving\_travel.duration$ > $new\_meeting.start\_date$ - $before\_meeting.leaving\_travel.end\_time$}
		\State $arriving\_travel$ := \Call{best\_travel}{$before\_meeting.leaving\_travel.arrival$, $new\_meeting.location$}
		\If{$arriving\_travel.duration$ > $new\_meeting.start\_date$ - $before\_meeting.leaving\_travel.end\_time$}
			\State $arriving\_travel$ := \Call{best\_travel}{$before\_meeting.location$, $new\_meeting.location$}
			\If{$arriving\_travel.duration$ > $new\_meeting.start\_date$ - $before\_meeting.end\_date$}
				\State mark $new\_meeting$ as inconsistent
				\State \textbf{return}				
			\EndIf
		\EndIf
	\EndIf
	\If{$after\_meeting$ is not NULL \textbf{and} $leaving\_travel$.$duration$ > $after\_meeting$.$arriving\_travel$.$start\_time$ - $new\_meeting$.$end\_date$}
		\State $leaving\_travel$ := \Call{best\_travel}{$new\_meeting.location$, $after\_meeting.arriving\_travel.departure$}
		\If{$leaving\_travel.duration$ > $after\_meeting.arriving\_travel.start\_time$ - $new\_meeting.end\_date$}
			\State $leaving\_travel$ := \Call{best\_travel}{$new\_meeting.location$, $before\_meeting.location$}
			\If{$leaving\_travel.duration$ > $after\_meeting.start\_date$ - $new\_meeting.end\_date$}
				\State mark $new\_meeting$ as inconsistent
				\State \textbf{return}				
			\EndIf
		\EndIf
	\EndIf
	\Statex
	\State $overlapping\_breaks$ := all breaks of $user$ such that they overlap in time with $new\_meeting$ and its travels
	\ForAll{$break$ \textbf{in} $overlapping\_breaks$}
		\State \Call{update\_break}{$break$, $new\_meeting$ ,$arriving\_travel$, $leaving\_travel$}
		\If{$break$ is not doable}
			\State mark $new\_meeting$ as inconsistent
			\State \textbf{return}	
		\EndIf
	\EndFor
	\Statex
	\State $new\_meeting.arriving\_travel$ := $arriving\_travel$
	\State $new\_meeting.leaving\_travel$ := $leaving\_travel$
	%\State \Call{store}{$new\_meeting$} % probably we need to store it anyway
	\State \textbf{return}
\EndFunction
\end{algorithmic}